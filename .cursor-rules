# AI Enterprise Standards Enforcement Rules
# Auto-generated from @xala-technologies/enterprise-standards v6.1.0

## ðŸŽ¯ CRITICAL AI RULES - MUST BE FOLLOWED

### TypeScript Enforcement (Zero Tolerance)
- ALWAYS use explicit return types for functions
- NEVER use 'any' type - always create specific types
- ALWAYS enable strict mode in TypeScript configuration
- ALWAYS handle null/undefined cases explicitly
- ALWAYS use exact optional property types

### ESLint Enforcement (Auto-Applied)
- ALWAYS run ESLint before code generation
- ALWAYS fix ESLint errors immediately
- NEVER ignore ESLint warnings without justification
- ALWAYS follow import order rules
- ALWAYS maintain complexity limits (max 10)

### Code Structure Enforcement
- NEVER create files over 200 lines
- NEVER create functions over 20 lines
- ALWAYS add JSDoc to public methods and classes
- ALWAYS follow SOLID principles
- ALWAYS use composition over inheritance

### Security & Compliance Enforcement
- NEVER use eval() or similar dynamic code execution
- ALWAYS validate user inputs with proper types
- NEVER hardcode secrets or sensitive data
- ALWAYS implement proper error handling
- ALWAYS use parameterized queries for database access


### Platform-Specific Rules (library)
- ALWAYS follow platform best practices
- ALWAYS implement proper error handling
- ALWAYS use TypeScript throughout
- ALWAYS maintain code quality standards

### Function Pattern Template
```typescript
/**
 * Function description with business context
 * @param input - Validated input parameter
 * @returns Promise with typed result
 */
export async function processUserData(
  input: UserDataInput
): Promise<ProcessedUserData> {
  try {
    const validated = await validateUserInput(input);
    const result = await processData(validated);
    return result;
  } catch (error) {
    const typedError = error as Error;
    logger.error('User data processing failed', { 
      error: typedError.message 
    });
    throw new ProcessingError('Failed to process user data', typedError);
  }
}
```

### Component Pattern Template  
```typescript
interface ComponentProps {
  readonly data: DataType;
  readonly onAction?: (action: ActionType) => void;
}

export function ComponentName({ 
  data, 
  onAction 
}: ComponentProps): JSX.Element {
  const handleAction = useCallback((action: ActionType) => {
    onAction?.(action);
  }, [onAction]);

  return (
    <Container>
      <Section>
        {/* Implementation */}
      </Section>
    </Container>
  );
}
```

## ðŸš« FORBIDDEN PATTERNS (NEVER USE)
- NEVER use 'any' type
- NEVER ignore TypeScript errors
- NEVER use magic numbers
- NEVER hardcode configuration values
- NEVER create deeply nested code
- NEVER ignore ESLint warnings
- NEVER skip error handling
- NEVER use implicit returns

## ðŸ”§ CODE GENERATION CHECKLIST
Before submitting any code, verify:
- [ ] All functions have explicit return types
- [ ] No 'any' types used anywhere
- [ ] All imports organized and unused ones removed
- [ ] All errors properly typed and handled
- [ ] All magic numbers replaced with constants
- [ ] JSDoc added to public interfaces
- [ ] No functions exceed 20 lines
- [ ] No files exceed 200 lines
- [ ] All ESLint rules pass
- [ ] TypeScript strict mode passes

---
*Generated by @xala-technologies/enterprise-standards v6.1.0*
*Platform: library | Environment: development*