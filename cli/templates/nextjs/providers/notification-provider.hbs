/**
 * @fileoverview {{componentName}} - Enterprise Notification System
 * @description Toast notifications with queue management and persistence
 * @version 5.0.0
 * @compliance Enterprise Standards, Accessibility, WCAG AAA
 */

'use client';

import React, { createContext, useContext, useState, useCallback, useEffect, useRef } from 'react';

export type NotificationType = 'success' | 'error' | 'warning' | 'info' | 'default';
export type NotificationPosition = 'top-left' | 'top-center' | 'top-right' | 'bottom-left' | 'bottom-center' | 'bottom-right';

export interface Notification {
  readonly id: string;
  readonly type: NotificationType;
  readonly title: string;
  readonly message?: string;
  readonly duration?: number;
  readonly persistent?: boolean;
  readonly action?: {
    readonly label: string;
    readonly onClick: () => void;
  };
  readonly onClose?: () => void;
  readonly icon?: React.ReactNode;
  readonly timestamp: number;
  readonly metadata?: Record<string, any>;
}

export interface NotificationContextValue {
  readonly notifications: ReadonlyArray<Notification>;
  readonly show: (notification: Omit<Notification, 'id' | 'timestamp'>) => string;
  readonly success: (title: string, message?: string, options?: Partial<Notification>) => string;
  readonly error: (title: string, message?: string, options?: Partial<Notification>) => string;
  readonly warning: (title: string, message?: string, options?: Partial<Notification>) => string;
  readonly info: (title: string, message?: string, options?: Partial<Notification>) => string;
  readonly dismiss: (id: string) => void;
  readonly dismissAll: () => void;
  readonly update: (id: string, updates: Partial<Notification>) => void;
}

const NotificationContext = createContext<NotificationContextValue | undefined>(undefined);

interface {{componentName}}Props {
  readonly children: React.ReactNode;
  readonly position?: NotificationPosition;
  readonly maxNotifications?: number;
  readonly defaultDuration?: number;
  readonly persistKey?: string;
  readonly enablePersistence?: boolean;
  readonly enableSound?: boolean;
  readonly soundUrl?: string;
  readonly pauseOnHover?: boolean;
  readonly stackNotifications?: boolean;
  readonly animationDuration?: number;
}

/**
 * Notification Provider for toast-style notifications
 * Manages notification queue, persistence, and display
 */
export const {{componentName}}: React.FC<{{componentName}}Props> = ({
  children,
  position = 'top-right',
  maxNotifications = 5,
  defaultDuration = 5000,
  persistKey = 'notifications',
  enablePersistence = false,
  enableSound = false,
  soundUrl = '/sounds/notification.mp3',
  pauseOnHover = true,
  stackNotifications = true,
  animationDuration = 300,
}) => {
  const [notifications, setNotifications] = useState<Notification[]>([]);
  const audioRef = useRef<HTMLAudioElement | null>(null);
  const timersRef = useRef<Map<string, NodeJS.Timeout>>(new Map());
  const hoveredRef = useRef<Set<string>>(new Set());

  // Initialize audio
  useEffect(() => {
    if (enableSound && typeof window !== 'undefined') {
      audioRef.current = new Audio(soundUrl);
      audioRef.current.volume = 0.5;
    }
  }, [enableSound, soundUrl]);

  // Load persisted notifications
  useEffect(() => {
    if (enablePersistence && typeof window !== 'undefined') {
      const stored = localStorage.getItem(persistKey);
      if (stored) {
        try {
          const parsed = JSON.parse(stored) as Notification[];
          const valid = parsed.filter(n => n.persistent && Date.now() - n.timestamp < 86400000); // 24 hours
          setNotifications(valid);
        } catch (error) {
          console.error('Failed to load persisted notifications:', error);
        }
      }
    }
  }, [enablePersistence, persistKey]);

  // Persist notifications
  useEffect(() => {
    if (enablePersistence && typeof window !== 'undefined') {
      const toPersist = notifications.filter(n => n.persistent);
      if (toPersist.length > 0) {
        localStorage.setItem(persistKey, JSON.stringify(toPersist));
      } else {
        localStorage.removeItem(persistKey);
      }
    }
  }, [notifications, enablePersistence, persistKey]);

  // Auto-dismiss notifications
  const scheduleDismiss = useCallback((notification: Notification) => {
    if (notification.persistent || !notification.duration) return;

    const timer = setTimeout(() => {
      dismiss(notification.id);
    }, notification.duration);

    timersRef.current.set(notification.id, timer);
  }, []);

  const cancelDismiss = useCallback((id: string) => {
    const timer = timersRef.current.get(id);
    if (timer) {
      clearTimeout(timer);
      timersRef.current.delete(id);
    }
  }, []);

  const generateId = (): string => {
    return `notification-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
  };

  const playSound = useCallback(() => {
    if (enableSound && audioRef.current) {
      audioRef.current.play().catch(error => {
        console.error('Failed to play notification sound:', error);
      });
    }
  }, [enableSound]);

  const show = useCallback((notification: Omit<Notification, 'id' | 'timestamp'>): string => {
    const id = generateId();
    const newNotification: Notification = {
      ...notification,
      id,
      timestamp: Date.now(),
      duration: notification.duration ?? defaultDuration,
    };

    setNotifications(prev => {
      // Limit max notifications
      const updated = stackNotifications 
        ? [...prev, newNotification]
        : [newNotification, ...prev];
      
      if (updated.length > maxNotifications) {
        const toRemove = updated.slice(0, updated.length - maxNotifications);
        toRemove.forEach(n => cancelDismiss(n.id));
        return updated.slice(-maxNotifications);
      }
      
      return updated;
    });

    scheduleDismiss(newNotification);
    playSound();

    return id;
  }, [defaultDuration, maxNotifications, stackNotifications, scheduleDismiss, playSound, cancelDismiss]);

  const success = useCallback((title: string, message?: string, options?: Partial<Notification>): string => {
    return show({ ...options, type: 'success', title, message });
  }, [show]);

  const error = useCallback((title: string, message?: string, options?: Partial<Notification>): string => {
    return show({ ...options, type: 'error', title, message, duration: options?.duration ?? 10000 });
  }, [show]);

  const warning = useCallback((title: string, message?: string, options?: Partial<Notification>): string => {
    return show({ ...options, type: 'warning', title, message });
  }, [show]);

  const info = useCallback((title: string, message?: string, options?: Partial<Notification>): string => {
    return show({ ...options, type: 'info', title, message });
  }, [show]);

  const dismiss = useCallback((id: string) => {
    cancelDismiss(id);
    setNotifications(prev => {
      const notification = prev.find(n => n.id === id);
      if (notification?.onClose) {
        notification.onClose();
      }
      return prev.filter(n => n.id !== id);
    });
  }, [cancelDismiss]);

  const dismissAll = useCallback(() => {
    timersRef.current.forEach(timer => clearTimeout(timer));
    timersRef.current.clear();
    setNotifications([]);
  }, []);

  const update = useCallback((id: string, updates: Partial<Notification>) => {
    setNotifications(prev => prev.map(n => 
      n.id === id ? { ...n, ...updates } : n
    ));
  }, []);

  const handleMouseEnter = useCallback((id: string) => {
    if (pauseOnHover) {
      hoveredRef.current.add(id);
      cancelDismiss(id);
    }
  }, [pauseOnHover, cancelDismiss]);

  const handleMouseLeave = useCallback((id: string) => {
    if (pauseOnHover) {
      hoveredRef.current.delete(id);
      const notification = notifications.find(n => n.id === id);
      if (notification && !notification.persistent && notification.duration) {
        scheduleDismiss(notification);
      }
    }
  }, [pauseOnHover, notifications, scheduleDismiss]);

  const value: NotificationContextValue = {
    notifications,
    show,
    success,
    error,
    warning,
    info,
    dismiss,
    dismissAll,
    update,
  };

  const getPositionClasses = () => {
    const base = 'fixed z-50 pointer-events-none';
    const positions = {
      'top-left': 'top-4 left-4',
      'top-center': 'top-4 left-1/2 -translate-x-1/2',
      'top-right': 'top-4 right-4',
      'bottom-left': 'bottom-4 left-4',
      'bottom-center': 'bottom-4 left-1/2 -translate-x-1/2',
      'bottom-right': 'bottom-4 right-4',
    };
    return `${base} ${positions[position]}`;
  };

  const getIconForType = (type: NotificationType) => {
    switch (type) {
      case 'success':
        return (
          <svg className="w-5 h-5 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M5 13l4 4L19 7" />
          </svg>
        );
      case 'error':
        return (
          <svg className="w-5 h-5 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
          </svg>
        );
      case 'warning':
        return (
          <svg className="w-5 h-5 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" />
          </svg>
        );
      case 'info':
        return (
          <svg className="w-5 h-5 text-blue-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
          </svg>
        );
      default:
        return null;
    }
  };

  return (
    <NotificationContext.Provider value={value}>
      {children}
      
      {/* Notification Container */}
      <div className={getPositionClasses()} aria-live="polite" aria-atomic="true">
        <div className={`space-y-2 ${stackNotifications ? 'flex flex-col-reverse' : 'flex flex-col'}`}>
          {notifications.map(notification => (
            <div
              key={notification.id}
              className="pointer-events-auto"
              onMouseEnter={() => handleMouseEnter(notification.id)}
              onMouseLeave={() => handleMouseLeave(notification.id)}
              style={{
                animation: `slideIn ${animationDuration}ms ease-out`,
              }}
            >
              <div className="max-w-sm w-full bg-background border border-border rounded-lg shadow-lg overflow-hidden">
                <div className="p-4">
                  <div className="flex items-start">
                    {(notification.icon || getIconForType(notification.type)) && (
                      <div className="flex-shrink-0 mr-3">
                        {notification.icon || getIconForType(notification.type)}
                      </div>
                    )}
                    <div className="flex-1">
                      <p className="text-sm font-medium text-foreground">
                        {notification.title}
                      </p>
                      {notification.message && (
                        <p className="mt-1 text-sm text-muted-foreground">
                          {notification.message}
                        </p>
                      )}
                      {notification.action && (
                        <button
                          onClick={notification.action.onClick}
                          className="mt-2 text-sm font-medium text-primary hover:text-primary/80"
                        >
                          {notification.action.label}
                        </button>
                      )}
                    </div>
                    {!notification.persistent && (
                      <button
                        onClick={() => dismiss(notification.id)}
                        className="flex-shrink-0 ml-3 text-muted-foreground hover:text-foreground"
                        aria-label="Dismiss notification"
                      >
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M6 18L18 6M6 6l12 12" />
                        </svg>
                      </button>
                    )}
                  </div>
                </div>
              </div>
            </div>
          ))}
        </div>
      </div>

      <style jsx>{`
        @keyframes slideIn {
          from {
            transform: translateX(100%);
            opacity: 0;
          }
          to {
            transform: translateX(0);
            opacity: 1;
          }
        }
      `}</style>
    </NotificationContext.Provider>
  );
};

/**
 * Hook to access notification context
 */
export const useNotifications = () => {
  const context = useContext(NotificationContext);
  if (!context) {
    throw new Error('useNotifications must be used within a NotificationProvider');
  }
  return context;
};

{{componentName}}.displayName = '{{componentName}}';