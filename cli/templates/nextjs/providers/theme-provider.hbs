/**
 * @fileoverview {{componentName}} - Enterprise Theme Provider
 * @description SSR-safe theme provider using CSS custom properties
 * @version 5.0.0
 * @compliance SSR-Safe, No hooks in UI components, Token-based, WCAG AAA
 */

'use client';

import React, { createContext, useContext, useEffect, useState } from 'react';

export type Theme = 'light' | 'dark' | 'high-contrast' | 'system';
export type ResolvedTheme = 'light' | 'dark' | 'high-contrast';

interface ThemeContextValue {
  readonly theme: Theme;
  readonly resolvedTheme: ResolvedTheme;
  readonly setTheme: (theme: Theme) => void;
  readonly themes: ReadonlyArray<Theme>;
}

const ThemeContext = createContext<ThemeContextValue | undefined>(undefined);

/**
 * Script to inject into HTML to prevent theme flash
 * This runs before React hydration
 */
export const themeInitScript = `
  (function() {
    function getTheme() {
      const stored = localStorage.getItem('theme');
      if (stored && ['light', 'dark', 'high-contrast', 'system'].includes(stored)) {
        return stored;
      }
      return 'system';
    }
    
    function resolveTheme(theme) {
      if (theme === 'system') {
        return window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
      }
      return theme;
    }
    
    const theme = getTheme();
    const resolved = resolveTheme(theme);
    document.documentElement.setAttribute('data-theme', resolved);
    document.documentElement.style.colorScheme = resolved === 'dark' ? 'dark' : 'light';
  })();
`;

interface {{componentName}}Props {
  readonly children: React.ReactNode;
  readonly defaultTheme?: Theme;
  readonly storageKey?: string;
  readonly enableSystem?: boolean;
  readonly disableTransitions?: boolean;
  readonly themes?: ReadonlyArray<Theme>;
}

/**
 * Theme Provider using CSS custom properties
 * Manages theme state and provides context to the application
 * UI components should NOT use this context directly - they use CSS variables
 */
export const {{componentName}}: React.FC<{{componentName}}Props> = ({
  children,
  defaultTheme = 'system',
  storageKey = 'theme',
  enableSystem = true,
  disableTransitions = false,
  themes = ['light', 'dark', 'high-contrast', 'system'],
}) => {
  const [theme, setThemeState] = useState<Theme>(defaultTheme);
  const [resolvedTheme, setResolvedTheme] = useState<ResolvedTheme>('light');
  const [mounted, setMounted] = useState(false);

  // Handle system theme changes
  useEffect(() => {
    setMounted(true);
    
    // Get initial theme from localStorage or default
    const stored = localStorage.getItem(storageKey) as Theme | null;
    if (stored && themes.includes(stored)) {
      setThemeState(stored);
    }

    if (!enableSystem) return;

    const mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    const handleChange = () => {
      if (theme === 'system') {
        const resolved = mediaQuery.matches ? 'dark' : 'light';
        setResolvedTheme(resolved);
        document.documentElement.setAttribute('data-theme', resolved);
      }
    };

    mediaQuery.addEventListener('change', handleChange);
    return () => mediaQuery.removeEventListener('change', handleChange);
  }, [enableSystem, storageKey, theme, themes]);

  // Resolve theme based on system preference
  useEffect(() => {
    if (!mounted) return;

    let resolved: ResolvedTheme;
    if (theme === 'system' && enableSystem) {
      resolved = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    } else if (theme === 'system') {
      resolved = 'light';
    } else {
      resolved = theme as ResolvedTheme;
    }

    setResolvedTheme(resolved);

    // Apply theme to document
    const root = document.documentElement;
    
    if (disableTransitions) {
      root.classList.add('theme-transitioning');
    }

    root.setAttribute('data-theme', resolved);
    root.style.colorScheme = resolved === 'dark' ? 'dark' : 'light';

    if (disableTransitions) {
      // Force reflow
      void root.offsetHeight;
      root.classList.remove('theme-transitioning');
    }
  }, [theme, enableSystem, mounted, disableTransitions]);

  const setTheme = (newTheme: Theme) => {
    setThemeState(newTheme);
    localStorage.setItem(storageKey, newTheme);
  };

  const value: ThemeContextValue = {
    theme,
    resolvedTheme,
    setTheme,
    themes,
  };

  return (
    <ThemeContext.Provider value={value}>
      {children}
    </ThemeContext.Provider>
  );
};

/**
 * Hook to access theme context
 * NOTE: UI components should NOT use this - they should use CSS variables
 * This is only for theme management components
 */
export const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within a ThemeProvider');
  }
  return context;
};

/**
 * Inline script component to prevent theme flash
 * Add this to your app's <head>
 */
export const ThemeScript: React.FC<{ nonce?: string }> = ({ nonce }) => {
  return (
    <script
      nonce={nonce}
      dangerouslySetInnerHTML={{ __html: themeInitScript }}
    />
  );
};

{{componentName}}.displayName = '{{componentName}}';