/**
 * @fileoverview {{componentName}} - Enterprise Authentication Provider
 * @description Authentication context provider for SaaS applications
 * @version 5.0.0
 * @compliance Enterprise Standards, GDPR, NSM Security
 */

'use client';

import React, { createContext, useContext, useEffect, useState, useCallback } from 'react';

export interface User {
  readonly id: string;
  readonly email: string;
  readonly name: string;
  readonly avatar?: string;
  readonly role: string;
  readonly permissions: ReadonlyArray<string>;
  readonly metadata?: Record<string, any>;
}

export interface AuthSession {
  readonly user: User | null;
  readonly accessToken: string | null;
  readonly refreshToken: string | null;
  readonly expiresAt: number | null;
  readonly isAuthenticated: boolean;
  readonly isLoading: boolean;
}

export interface AuthContextValue extends AuthSession {
  readonly login: (credentials: LoginCredentials) => Promise<void>;
  readonly logout: () => Promise<void>;
  readonly register: (data: RegisterData) => Promise<void>;
  readonly refreshSession: () => Promise<void>;
  readonly updateUser: (updates: Partial<User>) => Promise<void>;
  readonly checkPermission: (permission: string) => boolean;
  readonly checkRole: (role: string) => boolean;
}

export interface LoginCredentials {
  readonly email: string;
  readonly password: string;
  readonly rememberMe?: boolean;
  readonly mfaCode?: string;
}

export interface RegisterData {
  readonly email: string;
  readonly password: string;
  readonly name: string;
  readonly acceptTerms: boolean;
  readonly marketingConsent?: boolean;
}

const AuthContext = createContext<AuthContextValue | undefined>(undefined);

interface {{componentName}}Props {
  readonly children: React.ReactNode;
  readonly apiEndpoint?: string;
  readonly storageKey?: string;
  readonly enableAutoRefresh?: boolean;
  readonly refreshInterval?: number;
  readonly onAuthStateChange?: (session: AuthSession) => void;
  readonly requireAuth?: boolean;
  readonly loadingComponent?: React.ReactNode;
  readonly unauthorizedComponent?: React.ReactNode;
}

/**
 * Authentication Provider for enterprise SaaS applications
 * Manages auth state, tokens, and user sessions
 * Compliant with Norwegian security standards (NSM)
 */
export const {{componentName}}: React.FC<{{componentName}}Props> = ({
  children,
  apiEndpoint = '/api/auth',
  storageKey = 'auth-session',
  enableAutoRefresh = true,
  refreshInterval = 5 * 60 * 1000, // 5 minutes
  onAuthStateChange,
  requireAuth = false,
  loadingComponent = <div>Loading...</div>,
  unauthorizedComponent = <div>Unauthorized</div>,
}) => {
  const [user, setUser] = useState<User | null>(null);
  const [accessToken, setAccessToken] = useState<string | null>(null);
  const [refreshToken, setRefreshToken] = useState<string | null>(null);
  const [expiresAt, setExpiresAt] = useState<number | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  // Load session from storage on mount
  useEffect(() => {
    const loadSession = async () => {
      try {
        const stored = localStorage.getItem(storageKey);
        if (stored) {
          const session = JSON.parse(stored);
          
          // Check if session is expired
          if (session.expiresAt && Date.now() < session.expiresAt) {
            setUser(session.user);
            setAccessToken(session.accessToken);
            setRefreshToken(session.refreshToken);
            setExpiresAt(session.expiresAt);
          } else if (session.refreshToken) {
            // Try to refresh the session
            await refreshSessionWithToken(session.refreshToken);
          }
        }
      } catch (error) {
        console.error('Failed to load auth session:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadSession();
  }, [storageKey]);

  // Auto-refresh session
  useEffect(() => {
    if (!enableAutoRefresh || !refreshToken || !expiresAt) return;

    const timeUntilExpiry = expiresAt - Date.now();
    const refreshTime = Math.min(refreshInterval, timeUntilExpiry - 60000); // 1 minute before expiry

    if (refreshTime <= 0) {
      refreshSession();
      return;
    }

    const timer = setTimeout(() => {
      refreshSession();
    }, refreshTime);

    return () => clearTimeout(timer);
  }, [enableAutoRefresh, refreshToken, expiresAt, refreshInterval]);

  // Notify auth state changes
  useEffect(() => {
    if (onAuthStateChange) {
      const session: AuthSession = {
        user,
        accessToken,
        refreshToken,
        expiresAt,
        isAuthenticated: !!user && !!accessToken,
        isLoading,
      };
      onAuthStateChange(session);
    }
  }, [user, accessToken, refreshToken, expiresAt, isLoading, onAuthStateChange]);

  const saveSession = (session: Partial<AuthSession>) => {
    const data = {
      user: session.user || user,
      accessToken: session.accessToken || accessToken,
      refreshToken: session.refreshToken || refreshToken,
      expiresAt: session.expiresAt || expiresAt,
    };
    localStorage.setItem(storageKey, JSON.stringify(data));
  };

  const clearSession = () => {
    localStorage.removeItem(storageKey);
    setUser(null);
    setAccessToken(null);
    setRefreshToken(null);
    setExpiresAt(null);
  };

  const login = async (credentials: LoginCredentials) => {
    setIsLoading(true);
    try {
      const response = await fetch(`${apiEndpoint}/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(credentials),
      });

      if (!response.ok) {
        throw new Error('Login failed');
      }

      const data = await response.json();
      
      setUser(data.user);
      setAccessToken(data.accessToken);
      setRefreshToken(data.refreshToken);
      setExpiresAt(data.expiresAt);
      
      saveSession(data);
    } catch (error) {
      clearSession();
      throw error;
    } finally {
      setIsLoading(false);
    }
  };

  const logout = async () => {
    setIsLoading(true);
    try {
      if (accessToken) {
        await fetch(`${apiEndpoint}/logout`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${accessToken}`,
          },
        });
      }
    } catch (error) {
      console.error('Logout error:', error);
    } finally {
      clearSession();
      setIsLoading(false);
    }
  };

  const register = async (data: RegisterData) => {
    setIsLoading(true);
    try {
      const response = await fetch(`${apiEndpoint}/register`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(data),
      });

      if (!response.ok) {
        throw new Error('Registration failed');
      }

      const result = await response.json();
      
      // Auto-login after registration
      if (result.accessToken) {
        setUser(result.user);
        setAccessToken(result.accessToken);
        setRefreshToken(result.refreshToken);
        setExpiresAt(result.expiresAt);
        saveSession(result);
      }
    } finally {
      setIsLoading(false);
    }
  };

  const refreshSessionWithToken = async (token: string) => {
    try {
      const response = await fetch(`${apiEndpoint}/refresh`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ refreshToken: token }),
      });

      if (!response.ok) {
        throw new Error('Session refresh failed');
      }

      const data = await response.json();
      
      setUser(data.user);
      setAccessToken(data.accessToken);
      setRefreshToken(data.refreshToken);
      setExpiresAt(data.expiresAt);
      
      saveSession(data);
    } catch (error) {
      clearSession();
      throw error;
    }
  };

  const refreshSession = async () => {
    if (!refreshToken) {
      clearSession();
      return;
    }
    await refreshSessionWithToken(refreshToken);
  };

  const updateUser = async (updates: Partial<User>) => {
    if (!user || !accessToken) {
      throw new Error('Not authenticated');
    }

    setIsLoading(true);
    try {
      const response = await fetch(`${apiEndpoint}/user`, {
        method: 'PATCH',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${accessToken}`,
        },
        body: JSON.stringify(updates),
      });

      if (!response.ok) {
        throw new Error('User update failed');
      }

      const updatedUser = await response.json();
      setUser(updatedUser);
      saveSession({ user: updatedUser });
    } finally {
      setIsLoading(false);
    }
  };

  const checkPermission = useCallback((permission: string): boolean => {
    return user?.permissions?.includes(permission) || false;
  }, [user]);

  const checkRole = useCallback((role: string): boolean => {
    return user?.role === role;
  }, [user]);

  const value: AuthContextValue = {
    user,
    accessToken,
    refreshToken,
    expiresAt,
    isAuthenticated: !!user && !!accessToken,
    isLoading,
    login,
    logout,
    register,
    refreshSession,
    updateUser,
    checkPermission,
    checkRole,
  };

  // Handle auth requirements
  if (requireAuth && !isLoading && !user) {
    return <>{unauthorizedComponent}</>;
  }

  if (isLoading && requireAuth) {
    return <>{loadingComponent}</>;
  }

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

/**
 * Hook to access auth context
 */
export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

/**
 * HOC to protect components with authentication
 */
export const withAuth = <P extends object>(
  Component: React.ComponentType<P>,
  options?: {
    requiredPermissions?: string[];
    requiredRole?: string;
    fallback?: React.ReactNode;
  }
) => {
  return (props: P) => {
    const { isAuthenticated, isLoading, checkPermission, checkRole } = useAuth();

    if (isLoading) {
      return <>{options?.fallback || <div>Loading...</div>}</>;
    }

    if (!isAuthenticated) {
      return <>{options?.fallback || <div>Unauthorized</div>}</>;
    }

    if (options?.requiredPermissions) {
      const hasPermissions = options.requiredPermissions.every(checkPermission);
      if (!hasPermissions) {
        return <>{options?.fallback || <div>Insufficient permissions</div>}</>;
      }
    }

    if (options?.requiredRole && !checkRole(options.requiredRole)) {
      return <>{options?.fallback || <div>Incorrect role</div>}</>;
    }

    return <Component {...props} />;
  };
};

{{componentName}}.displayName = '{{componentName}}';